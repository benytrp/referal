import React, { useState, useEffect } from 'react';
import { RefreshCw, ArrowRight, ArrowLeft, Circle, Square } from 'lucide-react';

const ParadoxEngine = () => {
  const [rootInput, setRootInput] = useState('');
  const [currentPhase, setCurrentPhase] = useState('input');
  const [history, setHistory] = useState([]);
  const [currentContent, setCurrentContent] = useState('');
  const [reflections, setReflections] = useState([]);
  const [cycleCount, setCycleCount] = useState(0);
  const [isAtRoot, setIsAtRoot] = useState(false);

  const phases = [
    { id: 'input', name: 'ROOT QUESTION', icon: Circle },
    { id: 'refinement', name: 'REFINEMENT', icon: Square },
    { id: 'expansion', name: 'EXPANSION', icon: Circle },
    { id: 'folding', name: 'FOLDING', icon: Square },
    { id: 'contradiction', name: 'CONTRADICTION', icon: Circle },
    { id: 'paradox', name: 'PARADOX GENERATION', icon: Square },
    { id: 'reflection', name: 'META-REFLECTION', icon: Circle }
  ];

  const getCurrentPhaseIndex = () => {
    return phases.findIndex(p => p.id === currentPhase);
  };

  const getPhasePrompt = (phase) => {
    const prompts = {
      input: "Enter your root question, statement, or paradox. This becomes both your beginning and your destination.",
      refinement: `Looking at: "${rootInput}"\n\nREFINE this into its most essential contradiction. What is the core tension? Strip away everything except the paradox itself.`,
      expansion: `From your refinement, EXPAND outward. What new territories does this contradiction reveal? What questions emerge when you follow each thread?`,
      folding: `Now FOLD these expansions back onto themselves. Where do they contradict each other? What happens when you compress all possibilities into one point?`,
      contradiction: `Identify the CONTRADICTIONS within your folding. Let each contradiction spawn its opposite. What cannot coexist but must?`,
      paradox: `Generate NEW PARADOXES from these contradictions. Create impossible statements that feel true. Birth new impossibilities.`,
      reflection: `META-REFLECT on everything so far. What did this cycle reveal about your root input? How has "${rootInput}" changed while remaining the same? What new cycle does this suggest?`
    };
    return prompts[phase];
  };

  const advancePhase = () => {
    if (!currentContent.trim()) return;

    const newEntry = {
      phase: currentPhase,
      content: currentContent,
      timestamp: Date.now(),
      cycleCount: cycleCount
    };

    setHistory(prev => [...prev, newEntry]);

    if (currentPhase === 'reflection') {
      // Check if we've returned to root conceptually
      const similarity = checkSimilarityToRoot(currentContent);
      if (similarity > 0.7) {
        setIsAtRoot(true);
        setReflections(prev => [...prev, `CYCLE ${cycleCount + 1} COMPLETE: Returned to root through: ${currentContent.substring(0, 100)}...`]);
      } else {
        // Continue the spiral
        setCycleCount(prev => prev + 1);
        setCurrentPhase('refinement');
        setReflections(prev => [...prev, `CYCLE ${cycleCount + 1}: New spiral begins from: ${currentContent.substring(0, 100)}...`]);
      }
    } else {
      const nextPhaseIndex = (getCurrentPhaseIndex() + 1) % phases.length;
      if (nextPhaseIndex === 0) {
        setCurrentPhase('refinement');
      } else {
        setCurrentPhase(phases[nextPhaseIndex].id);
      }
    }

    setCurrentContent('');
  };

  const checkSimilarityToRoot = (content) => {
    // Simple similarity check - in reality this could be more sophisticated
    const rootWords = rootInput.toLowerCase().split(/\s+/);
    const contentWords = content.toLowerCase().split(/\s+/);
    const commonWords = rootWords.filter(word => contentWords.includes(word));
    return commonWords.length / Math.max(rootWords.length, contentWords.length);
  };

  const startNewCycle = () => {
    setIsAtRoot(false);
    setCycleCount(prev => prev + 1);
    setCurrentPhase('refinement');
    setCurrentContent('');
  };

  const jumpToAnyPoint = (entry) => {
    // Any point can become a new beginning
    setCurrentContent(entry.content);
    setCurrentPhase(entry.phase);
    setReflections(prev => [...prev, `JUMPED TO: ${entry.phase.toUpperCase()} from cycle ${entry.cycleCount}`]);
  };

  const resetToRoot = () => {
    setCurrentPhase('input');
    setHistory([]);
    setCurrentContent('');
    setReflections([]);
    setCycleCount(0);
    setIsAtRoot(false);
    setRootInput('');
  };

  if (currentPhase === 'input') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 text-white p-6">
        <div className="max-w-4xl mx-auto">
          <div className="text-center mb-8">
            <h1 className="text-4xl font-bold mb-4 bg-gradient-to-r from-purple-400 to-cyan-400 bg-clip-text text-transparent">
              THE INFINITE PARADOX ENGINE
            </h1>
            <p className="text-gray-300 text-lg">
              Enter the spiral. The only exit is through return.
            </p>
          </div>

          <div className="bg-gray-800/50 backdrop-blur rounded-lg p-8 border border-purple-500/30">
            <label className="block text-purple-300 text-sm font-medium mb-4">
              ROOT QUESTION / STATEMENT / PARADOX
            </label>
            <textarea
              value={rootInput}
              onChange={(e) => setRootInput(e.target.value)}
              className="w-full h-32 bg-gray-700/50 border border-purple-500/30 rounded-lg p-4 text-white placeholder-gray-400 focus:border-purple-400 focus:outline-none resize-none"
              placeholder="Enter anything that sparks inquiry... This becomes both your beginning and your destination."
            />
            <button
              onClick={() => {
                if (rootInput.trim()) {
                  setCurrentPhase('refinement');
                }
              }}
              disabled={!rootInput.trim()}
              className="mt-4 bg-gradient-to-r from-purple-600 to-cyan-600 hover:from-purple-700 hover:to-cyan-700 disabled:from-gray-600 disabled:to-gray-600 px-6 py-3 rounded-lg font-medium transition-all duration-200 flex items-center gap-2"
            >
              Enter the Spiral <ArrowRight size={20} />
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 text-white p-6">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="text-center mb-6">
          <h1 className="text-3xl font-bold mb-2 bg-gradient-to-r from-purple-400 to-cyan-400 bg-clip-text text-transparent">
            CYCLE {cycleCount + 1}
          </h1>
          <p className="text-gray-300">
            ROOT: "{rootInput}"
          </p>
        </div>

        {/* Phase Progress */}
        <div className="flex justify-center mb-8">
          <div className="flex items-center gap-2 bg-gray-800/50 rounded-full p-2">
            {phases.slice(1).map((phase, index) => {
              const Icon = phase.icon;
              const isActive = phase.id === currentPhase;
              const isPassed = getCurrentPhaseIndex() > index + 1;
              
              return (
                <div key={phase.id} className="flex items-center">
                  <div className={`w-10 h-10 rounded-full flex items-center justify-center ${
                    isActive ? 'bg-purple-600 text-white' : 
                    isPassed ? 'bg-gray-600 text-gray-300' : 
                    'bg-gray-700 text-gray-400'
                  }`}>
                    <Icon size={16} />
                  </div>
                  {index < phases.length - 2 && <ArrowRight size={16} className="text-gray-500 mx-1" />}
                </div>
              );
            })}
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Current Phase */}
          <div className="lg:col-span-2">
            <div className="bg-gray-800/50 backdrop-blur rounded-lg p-6 border border-purple-500/30">
              <div className="flex items-center gap-3 mb-4">
                <div className="w-3 h-3 bg-purple-500 rounded-full animate-pulse"></div>
                <h2 className="text-xl font-bold text-purple-300">
                  {phases.find(p => p.id === currentPhase)?.name}
                </h2>
              </div>
              
              <div className="mb-4 p-4 bg-gray-700/30 rounded-lg border border-gray-600">
                <p className="text-gray-300 text-sm leading-relaxed whitespace-pre-line">
                  {getPhasePrompt(currentPhase)}
                </p>
              </div>

              <textarea
                value={currentContent}
                onChange={(e) => setCurrentContent(e.target.value)}
                className="w-full h-40 bg-gray-700/50 border border-purple-500/30 rounded-lg p-4 text-white placeholder-gray-400 focus:border-purple-400 focus:outline-none resize-none"
                placeholder="Continue the spiral..."
              />

              <div className="flex gap-3 mt-4">
                <button
                  onClick={advancePhase}
                  disabled={!currentContent.trim()}
                  className="flex-1 bg-gradient-to-r from-purple-600 to-cyan-600 hover:from-purple-700 hover:to-cyan-700 disabled:from-gray-600 disabled:to-gray-600 px-4 py-3 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2"
                >
                  {currentPhase === 'reflection' ? 'Complete Cycle' : 'Continue'} 
                  <ArrowRight size={20} />
                </button>
                <button
                  onClick={resetToRoot}
                  className="bg-gray-700 hover:bg-gray-600 px-4 py-3 rounded-lg font-medium transition-all duration-200 flex items-center gap-2"
                >
                  <RefreshCw size={20} />
                  Reset
                </button>
              </div>

              {isAtRoot && (
                <div className="mt-4 p-4 bg-gradient-to-r from-green-800/30 to-blue-800/30 rounded-lg border border-green-500/30">
                  <p className="text-green-300 font-medium mb-2">🎯 RETURN DETECTED</p>
                  <p className="text-gray-300 text-sm mb-3">
                    You have returned to your root through the spiral. You may exit here, or continue deeper...
                  </p>
                  <button
                    onClick={startNewCycle}
                    className="bg-gradient-to-r from-green-600 to-blue-600 hover:from-green-700 hover:to-blue-700 px-4 py-2 rounded-lg font-medium transition-all duration-200 text-sm"
                  >
                    Dive Deeper
                  </button>
                </div>
              )}
            </div>
          </div>

          {/* History & Reflections */}
          <div className="space-y-6">
            {/* Quick Reflections */}
            <div className="bg-gray-800/50 backdrop-blur rounded-lg p-4 border border-purple-500/30">
              <h3 className="text-lg font-bold text-purple-300 mb-3">Spiral Trace</h3>
              <div className="space-y-2 max-h-60 overflow-y-auto">
                {reflections.map((reflection, index) => (
                  <div key={index} className="text-xs text-gray-400 p-2 bg-gray-700/30 rounded border-l-2 border-purple-500/50">
                    {reflection}
                  </div>
                ))}
              </div>
            </div>

            {/* History */}
            <div className="bg-gray-800/50 backdrop-blur rounded-lg p-4 border border-purple-500/30">
              <h3 className="text-lg font-bold text-purple-300 mb-3">Journey History</h3>
              <div className="space-y-2 max-h-80 overflow-y-auto">
                {history.map((entry, index) => (
                  <div 
                    key={index} 
                    onClick={() => jumpToAnyPoint(entry)}
                    className="text-xs p-3 bg-gray-700/30 rounded cursor-pointer hover:bg-gray-600/30 transition-colors border border-gray-600/50"
                  >
                    <div className="text-purple-300 font-medium mb-1">
                      {entry.phase.toUpperCase()} (C{entry.cycleCount})
                    </div>
                    <div className="text-gray-400 line-clamp-3">
                      {entry.content.substring(0, 100)}...
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ParadoxEngine;